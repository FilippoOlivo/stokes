---
title: "Topics in Computational Fluid Dynamics - Exam"
author: "Filippo Olivo"
date: "11 August 2025"
date-format: "D MMMM YYYY"
bibliography: bibliography.bib
csl: ieee.csl
format:
  pdf:
    title-block-style: none
    title-block-categories: false
    title-block-author-font-size: small
    title-block-date-font-size: small
    number-sections: true
---

This report contains the results valid as exam for the course of "Topics in Computational Fluid Dynamics". The goal of the project is to program and test a parallelized version of Stokes and Navier Stokes equations. All the simulations have been programmed using deal.II v$9.7.0$ library [@dealii]. The structure of this report will be the following:

#. Brief introduction to Stokes and Navier Stokes equations
#. Finite element discretization
#. Problem statement
#. Implementation details
#. Result

# Stokes and Navier-Stokes equations

Stokes and Navier-Stokes are mathematical models that describe the motion of incompressible, viscous fluids, in both liquid and gaseous form. These models govern how the fluid’s pressure and velocity fields evolve over time within a given domain. They are fundamentally based on two conservation principles:

- Mass conservation: This principle ensures that fluid cannot spontaneously appear or disappear. For incompressible flows, it leads to the condition:
    $$
    \nabla \cdot u = 0
    $$
    This expresses that the net volume of fluid flowing into any point is equal to the volume flowing out, thus preserving volume locally.

- Momentum conservation: This accounts for the effects of both internal and external forces acting on the fluid. Internal forces include viscous stresses (from fluid friction) and pressure gradients, while external forces typically consist of body forces such as gravity. In the Stokes equations, momentum conservation is expressed as:
    $$
    -\nu \Delta u + \nabla P = f
    $$
    where essentially the term $\nu \Delta u$ represents the linear viscous forces, while the term $\nabla P$ represents the forces caused by the pressure gradients. This formulation neglects the nonlinear convective acceleration term $(u \cdot \nabla)u$, which is small when inertial effects are negligible. This additional term has been included in the Navier–Stokes equations:
    $$
    (u \cdot \nabla)u - \nu \Delta u + \nabla p = f
    $$

In the context of fluid dynamics, a key quantity is the Reynolds number, a dimensionless quantity that estimates the ratio of inertial to viscous forces in the flow. It is defined as:
$$
\text{Re} = \frac{U L}{\nu}
$$
where $U$ is a characteristic velocity, $L$ is a characteristic length scale (e.g., the diameter of a cylinder), and $\nu$ is the kinematic viscosity of the fluid.

The Reynolds number governs the qualitative behavior of the flow. Based on its value, we can distinguish different flow regimes:

- $\text{Re} \leq 5$: Viscous forces dominate, and inertial effects are negligible. The flow remains attached to the geometry with no separation, and the solutions of the Stokes and Navier–Stokes equations are almost identical.
- $5 < \text{Re} < 40$: Steady recirculating vortices develop in the wake of obstacles.
– $\text{Re} \geq 40$: The flow becomes unsteady as phenomena such as periodic vortex shedding arise.

# Finite element discretisation

In this section, we discuss the finite element discretization for both Stokes and Navier-Stokes models separately. This section is primarily based on the book [@quarteroniValli] as well as the lecture slides provided during the course.

## Stokes

We begin by recalling the system of equations defining the Stokes model

$$
\begin{cases}
-\nu \Delta \vec{u} + \nabla P = \vec{f} & \text{ in } \Omega \\
\text{div}\vec{u} = 0 & \text{ in } \Omega \\
\vec{u} = \vec{g} & \text{ on } \Gamma_D \\
-P\vec{n} + \nu \frac{\partial \vec{u}}{\partial \vec{n}} = \vec{d} & \text{ on } \Gamma_N
\end{cases}
$$

Given this formulation, we derive the weak formulation of the Stokes problem by considering the following system:

$$
\begin{cases}
\int_\Omega (-\nu \Delta \vec{u} + \nabla P) \vec{v} = \int_\Omega \vec{f} \cdot \vec{v} & \forall \vec{v}\in V \\
\int_\Omega \text{div}( \vec{u} ) q = 0 & \forall q \in Q \\
\vec{u} = \vec{g} & \text{ on } \Gamma_D \\
\end{cases}
$$
where $V$ is the velocity test function space and $Q$ the pressure test function space.

Consider the first equation:
$$
\int_\Omega (-\nu \Delta \vec{u} + \nabla P) \vec{v}  = \nu \int_\Omega \nabla \vec{u} : \nabla \vec{v} - \int_\Omega P \text{div} (\vec{v}) - \underbrace{\int_{\Gamma} \nu \frac{\partial \vec{u}}{\partial \vec{n}} \cdot \vec{v}}_{\int_\Gamma \vec{d}\cdot \vec{v}}
$$
So the final system is:

$$
\begin{cases}
\nu \int_\Omega \nabla \vec{u} : \nabla \vec{v} - \int_\Omega P \text{div} (\vec{v}) = \int_\Gamma \vec{d}\cdot \vec{v} + \int_\Omega \vec{f}\vec{v} & \forall \vec{v}\in V \\
\int_\Omega \text{div}( \vec{u} ) q = 0 & \forall q \in Q \\
\vec{u} = \vec{g} & \text{ on } \Gamma_D \\
\end{cases}
$$
Given the weak formulation we can determine the following function spaces:
$$
V = [H^1(\Omega)]^d \,\, \text{ and } \,\, Q = L^2(\Omega)
$$
where $H^1(\Omega)$ is the Sobolev space of functions with square-integrable first derivatives, while $L^2(\Omega)$ is the space of square-integrable functions.

Consider now the two coercive forms:
$$
a: V\times V \rightarrow \mathbb{R} , \,\, a(\vec{u}, \vec{v} )= \int_\Omega \nu \nabla \vec{u} : \nabla \vec{v}
$$
$$
b: V \times Q \to \mathbb{R},
\quad b(\vec{v}, q) = \int_\Omega \text{div} (\vec{v}) P .
$$

This formulation satisfies the Ladyzhenskaya–Babuška–Brezzi (inf-sup) condition. As a result, the problem is well-posed in both the velocity and pressure spaces, and the solution pair $(\vec{u}, p)$ is unique up to an additive constant in the pressure component.

To consider the finite element approximation of the Stokes problem let us consider a mesh $\tau_h$ and subspaces of the test function space $V_h \subset V$ and $Q_h\subset Q$. We are essentially looking for $(u_h P_h) \in V_h \times Q_h$ such that the discrete weak formulation of the problem is satisfied:
$$
\begin{cases}
a(\vec{u_h}, \vec{v_h}) - b(\vec{v_h}, P_h) = F(\vec{v_h}) & \forall \vec{v_h}\in V_h \\
b(\vec{u_q}, q_h) = 0 & \forall q_h \in Q_h
\end{cases}
$$

In order to obtain a stable solution, the discrete finite element spaces must satisfy the discrete Ladyzhenskaya–Babuška–Brezzi (LBB) condition. One finite element pair that satisfies this condition is the Taylor–Hood element, which is composed of the finite element space $Q^{k+1}$ for the velocity and $Q^k$ for the pressure.

In algebraic form, the discrete saddle-point system reads:
$$
\begin{bmatrix}
A & B \\
B^T & 0
\end{bmatrix}
\begin{bmatrix}
U \\
P
\end{bmatrix}
=
\begin{bmatrix}
F \\
0
\end{bmatrix}
$$

where:

- $A_{ij} = \int_\Omega \nabla \vec{\phi}_i : \nabla \vec{\phi}_j \in \mathbb{R}^{N_u \times N_u}$ is the velocity stiffness matrix,
- $B_{jl} = -\int_\Omega \nabla \cdot \vec{\phi}_j , \psi_l \in \mathbb{R}^{N_u \times N_p}$ is the discrete divergence matrix.

Here, $\vec{\phi}_j$, with $j = 1, \dots, N_u$, are the test functions for the velocity space, and $\psi_l$, with $l = 1, \dots, N_p$, are the test functions for the pressure space. Once the system is assembled, solving it yields the discrete velocity and pressure fields.

On the other hand, if one uses an unstable finite element pair, such as $P^1$ for both the pressure and velocity spaces. In this case, a stabilization mechanism must be introduced to obtain a meaningful and stable solution. A widely used stabilization technique is the Brezzi–Pitkäranta method, which consists of adding a pressure–pressure stabilization term to the system matrix. This term counteracts the lack of inf-sup stability by penalizing pressure oscillations. The resulting stabilized system reads:

$$
\begin{bmatrix}
A & B \\
B^T & C
\end{bmatrix}
\begin{bmatrix}
U \\
P
\end{bmatrix}
=
\begin{bmatrix}
F \\
0
\end{bmatrix}
$$

where the stabilization matrix $C \in \mathbb{R}^{N_p \times N_p}$ is defined by:
$$
C_{lm} = \delta \sum_{K \in \mathcal{T}_h} h_K^2 \int_K \nabla \psi_l \cdot \nabla \psi_m , dx,
$$
with $\delta > 0$ a user-defined stabilization parameter, $h_K$ the diameter of element $K$, and $\psi_l$, $\psi_m$ the basis functions of the pressure space.

## Navier Stokes

The main difference between the weak formulation of the Navier–Stokes problem and that of the Stokes problem is the presence of the nonlinear convective term. To solve this problem, we employ Newton’s method, performing successive iterations to approximate the velocity and pressure fields.

In the Navier–Stokes case, we apply Newton’s method to the operator equation:
$$
\mathcal{G}(\vec{u},P) = \mathcal{L}(\vec{u}, P) - F = 0
$$
where 
$$
\mathcal{L}(\vec{u}, P) = \begin{bmatrix}
-\nu \Delta \vec{u} + \vec{u}\cdot\nabla\vec{u}+\nabla P \\ \text{div}(\vec{u}) \end{bmatrix} \,\, \text{and} \,\, F = \begin{bmatrix} \vec{f} \\ 0 \end{bmatrix}
$$

For Newton’s method, given $(\vec{u}_k, P_k)$, we need to find $(\delta \vec{u}_k, \delta P_k) \in V\times Q$ such that:
$$
D \mathcal{G}_{\vec{u}_k, P_k} (\delta \vec{u}_k, \delta P_k) = -\mathcal{G}(\vec{u}_k, P_k)
$$

Since $F$ is independent of $\vec{u}$ and $p$, this can be written as:

$$
D \mathcal{L}_{\vec{u}_k, P_k} (\delta \vec{u}_k, \delta P_k) =F-\mathcal{L}(\vec{u}_k, P_k)
$$
where
$$
D \mathcal{L}_{\vec{u}_k, P_k} (\delta \vec{u}_k, \delta P_k)  = \begin{bmatrix}-\nu\Delta \delta \vec{u} + \delta \vec{u} \cdot \nabla \vec{u}_k + \vec{u}_k \cdot \nabla \delta \vec{u} + \nabla \delta P \\ \text{div}(\delta \vec{u})\end{bmatrix}
$$
then,
$$
\begin{cases}
-\nu\Delta \delta \vec{u} + \delta \vec{u} \cdot \nabla \vec{u}_k + \vec{u}_k \cdot \nabla \delta \vec{u} + \nabla \delta P = \vec{f} + \nu \Delta \vec{u}_k - \vec{u}_k \cdot \nabla \vec{u}_k - \nabla P_k \\ \text{div}(\delta \vec{u}) = \text{div}(\vec{u}_k)
\end{cases}
$$
Consider now:
$$
\begin{cases}
-(\nu\Delta \delta \vec{u} + \nu \Delta \vec{u}_k) + (\vec{u_k}\cdot \nabla \delta \vec{u} + \vec{u_k}\cdot \nabla\vec{u}_k) + (\delta \vec{u} \cdot \nabla \vec{u}_k +  \vec{u}_k\cdot \nabla\vec{u}_k) + (\nabla \delta P + \nabla P_k) = \vec{f} + \vec{u}_k\cdot \nabla\vec{u}_k \\
\text{div}(\delta \vec{u}) = - \text{div} (\vec{u}_k)
\end{cases}
$$
Since $\vec{u}_{k+1} = \vec{u}k + \delta \vec{u}$ and $P_{k+1} = P_k + \delta p$, we can equivalently write:
$$
\begin{cases}
-\nu \Delta \vec{u}_{k+1} + \vec{u}_k \cdot \nabla \vec{u}_{k+1} + \vec{u}_{k+1} \cdot \nabla \vec{u}_k + \nabla P_{k+1} = \vec{f} + \vec{u}_k\cdot \nabla\vec{u}_k \\
\text{div}(\vec{u}_{k+1}) = 0
\end{cases}
$$

Similarly to what we did for the Stokes equations, let us derive the weak formulation of the problem. At each iteration of the Newton algorithm we must solve the following linear system:
$$
\begin{bmatrix}
A+N(U_k)+M(U_k) & B^T \\ B & 0 
\end{bmatrix} \begin{bmatrix}
 U_{k+1} \\  P_{k+1}
\end{bmatrix} = \begin{bmatrix}
F + D{U_k} \\ 0
\end{bmatrix}
$$
where:
$$
M_{ij} = \int_\Omega (\vec{\phi}_j \cdot \nabla)\vec{w} \cdot \vec{\phi}_i + \frac{1}{2} \int_\Omega \text{div}(\vec{\phi}_j)\vec{w} \cdot \vec{\phi}_i
$$
$$
N_{ij} = \int_\Omega (\vec{w}  \cdot \nabla) \vec{\phi}_j \cdot \vec{\phi}_i + \frac{1}{2} \int_\Omega \text{div}(\vec{w})\vec{\phi}_j \cdot \vec{\phi}_i
$$
$$
D_i = \int_\Omega \vec{\phi}_i (\vec{w} \cdot \nabla \vec{w})
$$

As in the Stokes case, the discrete Ladyzhenskaya–Babuška–Brezzi condition is satisfied for Taylor–Hood finite elements.

## Schur complement 

For the solution of the linear system, both in the Stokes and Navier–Stokes problems, we adopt a Schur complement strategy.

Given a saddle-point system of the form:

$$
\begin{bmatrix}
A & B^T \\
B & S
\end{bmatrix}
\begin{bmatrix}
U \\
P
\end{bmatrix}
=
\begin{bmatrix}
F \\
G
\end{bmatrix}
$$

we can eliminate the velocity unknown $U$ by solving the first block row:

$$
A U + B^T P = F \quad \Rightarrow \quad U = A^{-1}(F - B^T P)
$$

Substituting this expression into the second block row yields the Schur complement system:

$$
B A^{-1}(F - B^T P) + S P = G
\quad \Rightarrow \quad
(B A^{-1} B^T + S) P = B A^{-1} F - G
$$

We define the Schur complement matrix as:

$$
\Sigma := B A^{-1} B^T + S
$$

The reduced system for the pressure is then:

$$
\Sigma P = B A^{-1} F - G
$$

Once the pressure $P$ has been computed, the velocity $U$ is recovered via:

$$
U = A^{-1}(F - B^T P)
$$


In the Navier–Stokes problem, particularly at moderate Reynolds numbers, the matrix $A$ becomes strongly non-symmetric due to the convection term, which can significantly affect the robustness of the solver.

To improve solver robustness, we adopt an Augmented Lagrangian formulation by adding a grad–div stabilization term to the velocity block as proposed in [@tuto_navierstokes]:

$$
\tilde{A} = A + \gamma B^T W^{-1} B
$$

where:

- $\gamma > 0$ is a stabilization parameter,
- $W \approx M_p$ is the pressure mass matrix.

We do not form $\tilde{S}$ explicitly. Instead, we approximate its inverse as:

$$
\tilde{S}^{-1} \approx -(\nu + \gamma) M_p^{-1}
$$

This approximation is both cheap and effective. Once the pressure is obtained using this preconditioned system, the velocity is recovered by:

$$
u = \tilde{A}^{-1}(f - B^T p)
$$

# Problem statement

The problem under consideration is a variant of the flow past a cylinder benchmark, involving two distinct cylinders. The computational domain is a two-dimensional rectangular region of size $5 \times 1.5$. Each cylinder has radius $0.1$, with centers located at $(0.5, 1.0)$ and $(1.5,, 0.5)$.

The mesh for this configuration is shown in Figure 1.

![Mesh](img/mesh.png){width=80%}

We impose no-slip boundary conditions on $\Gamma_{\text{top}}$, $\Gamma_{\text{bottom}}$, $\Gamma_{\text{out}}$, and on the surfaces of both cylinders.
The inlet velocity, prescribed on $\Gamma_{\text{in}}$, is given by the parabolic profile

$$
u_{\text{in}}(y) = \frac{4}{H^2} , U_{\text{max}} , \big( H y - y^2 \big),
$$

where $H$ is the height of the domain and $U_{\text{max}}$ is the maximum inlet velocity. In our setup, we set $U_{\text{max}} = 1.0$. Finally, to ensure a unique pressure field, we impose a homogeneous Dirichlet condition on the pressure at $\Gamma_{\text{out}}$.

# Implementation details

All simulations were carried out using the deal.II finite element library. The implementation is based on the official tutorials [@tuto_stokes] for the Stokes solver and [@tuto_navierstokes] for the Navier–Stokes solver. The code is structured in a modular, object-oriented fashion, with the following main classes:


- `CommonCFD`: An abstract base class containing methods common to both the Stokes and Navier–Stokes solvers.
- `BaseStokes`: An abstract base class defining shared functionality between the stable and stabilized Stokes solver implementations.
- `StableStokes`: A concrete implementation of the Stokes solver using a stable Taylor–Hood finite element pair.
- `StabilizedStokes`: A stabilized Stokes solver implementation using an unstable $P^k–P^k$ finite element pair together with Brezzi–Pitkäranta stabilization.
- `NavierStokes`: The solver class for the incompressible Navier–Stokes equations.
- `InletBoundary`: A class that defines the parabolic inflow boundary condition described in the previous section.

![Class structure](img/class_structure.png){fig-cap="Boxes represent C++ classes. Bold arrows indicate inheritance (specialization). Simple arrows means that an instance of the target class is used or owned by the source class—for example." width=60%}

Moreover, we employed an adaptive refinement strategy based on Kelly Estimator.

The code used to run the tests is available at https://github.com/FilippoOlivo/stokes.
All classes are implemented using the Trilinos wrappers available in deal.II, ensuring that the code is scalable to distributed-memory environments.

# Results 

In this section we discuss the results of the simulations we have conducted on both the Stokes and Navier–Stokes problems. Specifically, this chapter will be structured as follows:

#. Stokes simulation
#. Navier-Stokes simulation
#. Computational performance and scalability

## Stokes simulations 

For the simple Stokes problem, we consider a scenario characterized by a low Reynolds number. Specifically, we set the kinematic viscosity to $\nu = 2$, which corresponds to a Reynolds number of $\text{Re} = 0.1$. This places us well within the Stokes regime, where inertial effects are negligible compared to viscous forces. The picture below shows an example of simulation with these parameters:

![Stokes simulation](img/stokes_example.png){width="90%"}

As we can see, the velocity field shows a symmetric pattern along the vertical axis of each cylinder, which is typical of the Stokes regime. The maximum velocity occurs in the region between the two cylinders due to flow acceleration. Regarding the pressure field, we observe a significant pressure drop, near the end of the second cylinder.

As mentioned in the previous section, we have also implemented a Stokes solver which employs a unstable FEM pair $P^k$–$P^k$ together with Brezzi–Pitkäranta stabilization. Recalling the section on finite element discretization, the key parameter to define is the stabilization parameter $\delta$. 

We compare the behavior of the FEM solution for different values of $\delta$. Specifically, the renderings below show the simulation results for $\delta = 1.0$, $0.1$, and $0.01$.

![Brezzi-Pitkaranta stabilization](img/bp_comparison.png){width="90%"}

From the three images above, we can see that a small $\delta$ leads to a spurious pressure field, indicating a violation of the inf-sup condition due to insufficient stabilization. On the other hand, a large $\delta$ results in a pressure field that is overly smooth and reduced in magnitude. In both cases, the velocity field remains mostly accurate.

## Navier-Stokes simulations

In this section, we focus on the Navier–Stokes model and investigate the behavior of the flow as the Reynolds number increases. To this end, we conduct a series of simulations where the inflow velocity is held constant, while the kinematic viscosity $\nu$ is progressively reduced. The viscosity ranges from a maximum value of $2.0$—corresponding to a low Reynolds number of $0.1$—down to a minimum of $0.002$, which yields a Reynolds number of $100$. In the figure below, each row corresponds to a different simulation where $\nu$ is decreased by an order of magnitude.

![Navier-Stokes at different Reynolds number](img/ns_reynolds_comparison.png){width="90%"}

From the figure above, we can see that at low Reynolds numbers, the flow is steady and symmetric, with smooth velocity and high pressure. In particular, for $\text{Re} = 0.1$, the Navier–Stokes solution is almost the same as the Stokes one shown in Figure 3. As the Reynolds number increases, inertial effects become more important, leading to longer wakes and asymmetries in the flow. Moreover, while the maximum velocity stays almost the same, the pressure becomes much smaller. This shows a transition from a flow dominated by viscosity to one where inertia plays a bigger role.

The following figure shows the Line Integral Convolution (LIC) [@LIC] plot for the different simulation at the different Reynolds number. LIC is a technique, implemented in ParaView, commonly used to visualize vector fields such as fluid flow as in our case. 

![Navier Stokes streamline at different Reynolds number](img/ns_vortex.png)

From the figure above we can see that at low Reynolds number, the flow is smooth and symmetric. As the Reynolds increases, inertial effects lead to wake formation and recirculation behind the cylinders. At $\text{Re} = 100$, vortices clearly form.

## Computational performance

In this section we discuss the computational requirements and scalability of Stokes and Navier Stokes models. All the tests have been performed on a Rocky Linux 8 machine with $2\times$ Intel(R) Xeon(R) Gold $6258R$ CPU @ $2.70$ GHz  with $28$ cores each and $256$ GB of RAM.

As mentioned in the previous section, we implemented an adaptive mesh refinement strategy to obtain a more accurate solution. Naturally, each refinement step significantly increases the number of degrees of freedom, resulting in higher computational cost. Specifically, we perform five refinement cycles, where in each step we refine the top $30\%$ of cells with the highest estimated error (according to the Kelly error estimator) and coarsen the bottom $10\%$ of cells with the lowest estimated error. 

To analyze the code’s scalability in greater detail, we divided it into the following logical sections and computed the speedup of each individually:

- **Initialize Schur complement**: initialization of the direct solver inside the Schur complement class which will compute the inverse of the pressure-pressure matrix.
- **Assemble**: assembling of the system matrix and the right-hand side. 
- **Residual computation**: time taken to compute the residual at each Newton iteration. 
- **Solve**: time taken to solve the linear system.

We focus on two types of scalability:

- **Strong scalability**: For a fixed problem size, we measure how the computational time changes as the number of processors increases.

In this section we consider only $5$ iterations of Newton method.

### Strong scalability

We consider the speed-up achieved when solving the Navier–Stokes problem with $1312626$ degrees of freedom, the number of DoFs after $6$ refinement steps. The figure below shows the speed-up values for different components of the algorithm as the number of processors increases. 

![Strong scalability](img/strong_scalability.png){width="60%"}

Overall, we observe a modest speed-up, reaching a maximum value of around $10$ when using $32$ processors. As expected, the components that benefit the most from parallelization are the assembly and residual computation. These parts involve relatively small communication and are also the most computationally intensive in the serial version of the program. In contrast, the solving phase and Schur complement initialization exhibit limited speed-up. This is likely due to the significant communication and memory overhead associated with these steps, which limits their scalability.

### Weak scalability

Here, we analyze how the computational time of the different components of the model changes as the number of degrees of freedom increases. For this analysis, we fixed the number of processors to $8$. The plot below illustrates the weak scalability:

![Weak scalability](img/weak_scalability.png){width="60%"}

The figure above shows that the overall time increases almost linearly with problem size. Assembly, residual computation, and Schur initialization follow similar trends while the solver scales more efficiently, showing only a moderate increase in time. On the other hand, the initial guess computation grows the fastest and becomes the dominant bottleneck for the largest problems.

# Conclusion

In this project, we presented an efficient deal.II implementation of a solver for both Stokes and Navier–Stokes problems. We achieved good scalability and overall performance in the assembly phase, while the scalability of other components could still be improved.

As future steps, in addition to performance improvements, we plan to implement an unsteady Navier–Stokes solver based on FEM, which will enable simulations at higher Reynolds numbers.

# References 

::: {#refs}
:::